"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/* eslint-env node */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const utils_1 = require("./utils");
function resolveModulesFromDir(modulesDir) {
    const namespaces = fs_1.default.readdirSync(modulesDir);
    const resolvedModules = [];
    namespaces.forEach(ns => {
        if (ns[0] !== '.' && fs_1.default.lstatSync(path_1.default.join(modulesDir, ns)).isDirectory()) {
            const namespacedModuleDir = path_1.default.join(modulesDir, ns);
            const modules = fs_1.default.readdirSync(namespacedModuleDir);
            modules.forEach(moduleName => {
                const moduleDir = path_1.default.join(namespacedModuleDir, moduleName);
                const entry = utils_1.getModuleEntry(moduleDir, moduleName);
                if (entry) {
                    const specifier = `${ns}/${moduleName}`;
                    resolvedModules.push({ entry, specifier });
                }
            });
        }
    });
    return resolvedModules;
}
function resolveModulesFromNpm(packageName) {
    let resolvedModules = [];
    try {
        const pkgJsonPath = require.resolve(`${packageName}/package.json`);
        const packageDir = path_1.default.dirname(pkgJsonPath);
        const lwcConfigFile = path_1.default.join(packageDir, utils_1.LWC_CONFIG_FILE);
        if (fs_1.default.existsSync(lwcConfigFile)) {
            resolvedModules = resolveModules({ rootDir: lwcConfigFile });
        }
        else {
            const pkgJson = JSON.parse(fs_1.default.readFileSync(pkgJsonPath, 'utf8'));
            if (pkgJson.lwc) {
                resolvedModules = resolveModulesFromList(pkgJson.lwc.modules, { root: packageDir });
            }
        }
    }
    catch (e) {
        /*noop*/
    }
    return resolvedModules;
}
function resolveModulesFromList(modules, { root }) {
    const resolvedModules = [];
    modules.forEach(moduleId => {
        if (!utils_1.isString(moduleId)) {
            const { name: specifier, path: modulePath } = moduleId;
            const entry = path_1.default.resolve(root, modulePath);
            if (fs_1.default.existsSync(entry)) {
                resolvedModules.push({ entry, specifier });
            }
        }
        else {
            const absPath = path_1.default.resolve(root, moduleId);
            // If the moduleRecord is a string check first in the file directory
            if (fs_1.default.existsSync(absPath)) {
                resolvedModules.push(...resolveModulesFromDir(absPath));
            }
            else {
                // Otherwise, try to see if is an npm package
                resolvedModules.push(...resolveModulesFromNpm(moduleId));
            }
        }
    });
    return resolvedModules;
}
function resolveModules(resolverConfig = {}) {
    const normalizedConfig = utils_1.normalizeConfig(resolverConfig);
    const rootConfig = utils_1.loadConfig(normalizedConfig.rootDir);
    const modules = utils_1.mergeModules(normalizedConfig.modules, rootConfig.modules);
    return resolveModulesFromList(modules, { root: normalizedConfig.rootDir });
}
exports.resolveModules = resolveModules;
//# sourceMappingURL=index.js.map