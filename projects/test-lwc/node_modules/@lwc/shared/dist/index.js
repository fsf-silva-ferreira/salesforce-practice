/**
 * Copyright (C) 2018 salesforce.com, inc.
 */
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function invariant(value, msg) {
    if (!value) {
        throw new Error(`Invariant Violation: ${msg}`);
    }
}
function isTrue(value, msg) {
    if (!value) {
        throw new Error(`Assert Violation: ${msg}`);
    }
}
function isFalse(value, msg) {
    if (value) {
        throw new Error(`Assert Violation: ${msg}`);
    }
}
function fail(msg) {
    throw new Error(msg);
}

var assert = /*#__PURE__*/Object.freeze({
    __proto__: null,
    invariant: invariant,
    isTrue: isTrue,
    isFalse: isFalse,
    fail: fail
});

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { assign, create, defineProperties, defineProperty, freeze, getOwnPropertyDescriptor, getOwnPropertyNames, getPrototypeOf, hasOwnProperty, keys, seal, setPrototypeOf, } = Object;
const { isArray } = Array;
const { filter: ArrayFilter, find: ArrayFind, forEach, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, push: ArrayPush, reduce: ArrayReduce, reverse: ArrayReverse, slice: ArraySlice, splice: ArraySplice, unshift: ArrayUnshift, } = Array.prototype;
const { charCodeAt: StringCharCodeAt, replace: StringReplace, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;
function isUndefined(obj) {
    return obj === undefined;
}
function isNull(obj) {
    return obj === null;
}
function isTrue$1(obj) {
    return obj === true;
}
function isFalse$1(obj) {
    return obj === false;
}
function isFunction(obj) {
    return typeof obj === 'function';
}
function isObject(obj) {
    return typeof obj === 'object';
}
function isString(obj) {
    return typeof obj === 'string';
}
function isNumber(obj) {
    return typeof obj === 'number';
}
const OtS = {}.toString;
function toString(obj) {
    if (obj && obj.toString) {
        // Arrays might hold objects with "null" prototype So using
        // Array.prototype.toString directly will cause an error Iterate through
        // all the items and handle individually.
        if (isArray(obj)) {
            return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
        }
        return obj.toString();
    }
    else if (typeof obj === 'object') {
        return OtS.call(obj);
    }
    else {
        return obj + emptyString;
    }
}
function getPropertyDescriptor(o, p) {
    do {
        const d = getOwnPropertyDescriptor(o, p);
        if (!isUndefined(d)) {
            return d;
        }
        o = getPrototypeOf(o);
    } while (o !== null);
}
const emptyString = '';

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/*
 * In IE11, symbols are expensive.
 * Due to the nature of the symbol polyfill. This method abstract the
 * creation of symbols, so we can fallback to string when native symbols
 * are not supported. Note that we can't use typeof since it will fail when transpiling.
 */
const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
function createHiddenField(key, namespace) {
    return (hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`);
}
const hiddenFieldsMap = new WeakMap();
function setHiddenField(o, field, value) {
    let valuesByField = hiddenFieldsMap.get(o);
    if (isUndefined(valuesByField)) {
        valuesByField = create(null);
        hiddenFieldsMap.set(o, valuesByField);
    }
    valuesByField[field] = value;
}
function getHiddenField(o, field) {
    const valuesByField = hiddenFieldsMap.get(o);
    if (!isUndefined(valuesByField)) {
        return valuesByField[field];
    }
}

export { ArrayFilter, ArrayFind, ArrayIndexOf, ArrayJoin, ArrayMap, ArrayPush, ArrayReduce, ArrayReverse, ArraySlice, ArraySplice, ArrayUnshift, StringCharCodeAt, StringReplace, StringSlice, StringToLowerCase, assert, assign, create, createHiddenField, defineProperties, defineProperty, emptyString, forEach, freeze, getHiddenField, getOwnPropertyDescriptor, getOwnPropertyNames, getPropertyDescriptor, getPrototypeOf, hasOwnProperty, isArray, isFalse$1 as isFalse, isFunction, isNull, isNumber, isObject, isString, isTrue$1 as isTrue, isUndefined, keys, seal, setHiddenField, setPrototypeOf, toString };
/** version: 1.3.7-226.4 */
